{"ast":null,"code":"import _slicedToArray from \"/Users/amandainnis/ReactProjects/react-site/portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/amandainnis/ReactProjects/react-site/portfolio/src/components/reusable/LineChart.js\";\nimport React, { createRef, useState, useRef, useEffect } from \"react\";\nimport * as d3 from \"d3\";\nimport * as moment from \"moment\"; // each charted value has a display name for tooltip\n// tooltip may or may not have a charted value\n// each line takes a color\n\nexport default function LineChart(props) {\n  const chart = createRef();\n  const defaultHeight = 220;\n  var containerElement;\n  let YOYdiff;\n\n  const _useState = useState(props.data),\n        _useState2 = _slicedToArray(_useState, 2),\n        chartData = _useState2[0],\n        setChartData = _useState2[1];\n\n  const _useState3 = useState(props.valueArray),\n        _useState4 = _slicedToArray(_useState3, 2),\n        valueArray = _useState4[0],\n        setValueArray = _useState4[1];\n\n  function prepMaxVal(myData, myArrayOfKeys) {\n    let tempArr = [];\n    let tempStartVal = [];\n\n    for (let i = 0; i < myData.length; i++) {\n      // push whatever arr[j] is in the array as a key into\n      for (let j = 0; j < myArrayOfKeys.length; j++) {\n        if (myData[i][myArrayOfKeys[j][\"dataKey\"]] !== null) {\n          tempArr.push(myData[i][myArrayOfKeys[j][\"dataKey\"]]);\n        }\n      }\n    }\n\n    return tempArr;\n  }\n\n  function getMaxVal(myData, myArrayOfKeys) {\n    // console.log(startVals, startValsRef);\n    let tempArr = prepMaxVal(myData, myArrayOfKeys);\n    let tempArrB = prepMaxVal(myData, myArrayOfKeys);\n    let tempMax = tempArr.reduce((a, b) => Math.max(a, b));\n    let tempMin = tempArrB.reduce((a, b) => Math.min(a, b));\n    return {\n      min: tempMin,\n      max: tempMax\n    };\n  }\n\n  function createChart(chartData, myArrayOfKeys, myID, numberFormatFn) {\n    containerElement = chart.current;\n    containerElement.innerHTML = \"\";\n    let tempMinMax = getMaxVal(chartData, myArrayOfKeys);\n    let minVal = tempMinMax.min;\n    let maxVal = tempMinMax.max; // let currentMonth = getCurrentMonth();\n\n    let margin = {\n      top: 20,\n      right: 60,\n      bottom: 0,\n      left: 10\n    }; //////////////////////// Establish the reused vals and the bound functions  ////////////////////////\n\n    let width = Number.isNaN(parseInt(d3.select(containerElement).style(\"width\"))) ? 0 : parseInt(d3.select(containerElement).style(\"width\")) - margin.left - margin.right;\n    let height = 220 - margin.top;\n    let justBisect = d3.bisector(d => chartData.indexOf(d)).left; //////////////////////// Set the scales  ////////////////////////\n\n    let x = d3.scaleLinear().range([0, width]);\n    let y = d3.scaleLinear().range([height, 0]); //////////////////////// Set the axis ////////////////////////\n\n    let xAxis = d3.axisBottom(x) // .ticks(12)\n    .tickFormat(function (d) {\n      return chartData[d].niceDateAbbrev;\n    }).tickPadding(6);\n    let yAxis = d3.axisRight(y).tickFormat(d => {\n      return numberFormatFn(d);\n    }).ticks(6).tickPadding(6); //////////////////////// Define the lines and/or areas  ////////////////////////\n    // put consts of the lines into the global scope\n    // defined means it can show gaps, isNan means it can have zero as a value\n\n    function createLineConsts() {\n      let myArr = [];\n      myArrayOfKeys.map((val, index) => {\n        console.log(val);\n        myArr.push(d3.line().defined(d => {\n          console.log(d[val]);\n          return !Number.isNaN(d[val][\"dataKey\"]);\n        }).x((d, i) => {\n          return x(i);\n        }).y(d => y(d[val][\"dataKey\"])));\n      });\n      return myArr;\n    }\n\n    const lineConst = createLineConsts();\n    console.log(lineConst); // //////////////////////// Define parent SVG  ////////////////////////\n    // const CVsvg = d3\n    //   .select(containerElement)\n    //   .append(\"svg\")\n    //   .attr(\"id\", myID)\n    //   .attr(\"width\", \"100%\")\n    //   .attr(\"height\", height + margin.top + margin.bottom + 40)\n    //   .append(\"g\")\n    //   .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n    // // // //////////////////////// Loop through / sort data  ////////////////////////\n    // chartData.forEach(d => {\n    //   d = +d;\n    // });\n    // // // //////////////////////// Set the domains  ////////////////////////\n    // x.domain([\n    //   parseInt(d3.min(chartData, (d, i) => i)),\n    //   parseInt(d3.max(chartData, (d, i) => i))\n    // ]);\n    // y.domain([minVal, maxVal]);\n    // // y.domain([0, maxVal]);\n    // // // //////////////////////// Append the lines / areas  ////////////////////////\n    // myArrayOfKeys.forEach((item, index) => {\n    //   CVsvg.append(\"path\")\n    //     .datum(chartData)\n    //     .attr(\"class\", `line${index} line`)\n    //     .attr(\"d\", lineConst[index])\n    //     .transition()\n    //     .duration(500);\n    //   console.log(lineConst[index]);\n    // });\n    // // // ///////////////////////  Add the X & Y Axis  ////////////////////////\n    // CVsvg.append(\"g\")\n    //   .attr(\"class\", \"yAxis\")\n    //   .attr(\"transform\", \"translate(\" + (width + 6) + \",0)\")\n    //   .call(yAxis);\n    // CVsvg.append(\"g\")\n    //   .attr(\"class\", \"xAxis\")\n    //   .attr(\"transform\", \"translate(0,\" + height + \")\")\n    //   .call(xAxis);\n    // // // //////////////////////// Add Line Tracing on mouse and markers   ////////////////////////\n    // const lineTrace = CVsvg.append(\"line\")\n    //   .attr(\"class\", \"mouse-line x\")\n    //   .style(\"opacity\", 0.5)\n    //   .attr(\"y1\", 0)\n    //   .attr(\"y2\", height);\n    // function createMarkers() {\n    //   myArrayOfKeys.forEach((val, index) => {\n    //     CVsvg.append(\"g\")\n    //       .attr(\"class\", `marker${index}`)\n    //       .append(\"circle\")\n    //       .attr(\"class\", `line-marker line${index}`)\n    //       .transition()\n    //       .duration(500)\n    //       .attr(\"r\", 5);\n    //   });\n    // }\n    // createMarkers();\n    // // // //////////////////////// Tooltip  ////////////////////////\n    // const tooltipDiv = d3\n    //   .select(containerElement)\n    //   .append(\"div\")\n    //   .attr(\"class\", \"tooltipDiv\")\n    //   .attr(\"id\", `${myID}Tooltip`);\n    // const dateContainer = tooltipDiv\n    //   .append(\"div\")\n    //   .attr(\"class\", \"text-container\");\n    // dateContainer\n    //   .append(\"div\")\n    //   .attr(\"class\", \"label-style mr-1\")\n    //   .text(\"Date\");\n    // const dateText = dateContainer.append(\"div\").attr(\"class\", \"value-text\");\n    // function createLineDivTextConsts() {\n    //   let myArr = [];\n    //   myArrayOfKeys.map((val, index) => {\n    //     myArr.push(tooltipDiv.append(\"div\").attr(\"class\", \"text-container\"));\n    //   });\n    //   return myArr;\n    // }\n    // const lineTextContainer = createLineDivTextConsts();\n    // myArrayOfKeys.forEach((val, index) => {\n    //   lineTextContainer[index]\n    //     .append(\"div\")\n    //     .attr(\"class\", \"label-style mr-1\")\n    //     .text(val[\"dataKey\"]);\n    //   lineTextContainer[index].append(\"div\").attr(\"class\", `dot line${index}`);\n    // });\n    // function createLineTextConsts() {\n    //   let myArr = [];\n    //   myArrayOfKeys.map((item, index) => {\n    //     myArr.push(\n    //       lineTextContainer[index]\n    //         .append(\"div\")\n    //         .attr(\"class\", `value-text lineTextConst${index}`)\n    //     );\n    //   });\n    //   return myArr;\n    // }\n    // const lineTextConsts = createLineTextConsts();\n    // // //////////////////////// Add Rect to Capture Mouse Movements  ////////////////////////\n    // CVsvg.append(\"rect\")\n    //   .on(\"mouseover\", () => {\n    //     lineTrace.style(\"display\", null);\n    //     d3.select(`#${myID} .mouse-line`).style(\"opacity\", \"1\");\n    //   })\n    //   .on(\"mousemove\", () => {\n    //     let xy = d3.mouse(d3.event.currentTarget);\n    //     let x0 = x.invert(xy[0]);\n    //     let mouseIndex = justBisect(chartData, x0, 1);\n    //     let d0 = chartData[mouseIndex - 1];\n    //     let d1 = chartData[mouseIndex];\n    //     let d;\n    //     if (d1 !== undefined) {\n    //       d = x0 - chartData.indexOf(d0) > chartData.indexOf(d1) - x0 ? d1 : d0;\n    //     } else {\n    //       d = d0;\n    //     }\n    //     lineTrace.attr(\n    //       \"transform\",\n    //       \"translate(\" + x(chartData.indexOf(d)) + \",0)\"\n    //     );\n    //     myArrayOfKeys.forEach((item, index) => {\n    //       d3.select(`#${myID} .marker${index}`).attr(\n    //         \"transform\",\n    //         \"translate(\" +\n    //           x(chartData.indexOf(d)) +\n    //           \",\" +\n    //           y(d[myArrayOfKeys[index][\"dataKey\"]]) +\n    //           \")\"\n    //       );\n    //     });\n    //     myArrayOfKeys.forEach((item, index) => {\n    //       let myText =\n    //         d[myArrayOfKeys[index][\"dataKey\"]] !== null\n    //           ? numberFormatFn(d[myArrayOfKeys[index][\"dataKey\"]])\n    //           : \"\";\n    //       d3.select(`#${myID}Tooltip .lineTextConst${index}`).text(myText);\n    //     });\n    //     dateText.text(d.niceDate + \" \" + d.niceTime);\n    //     d3.select(`#${myID} .mouse-line`).attr(\"y2\", height);\n    //   })\n    //   .on(\"mouseleave\", () => {\n    //     d3.select(`#${myID} .mouse-line`).style(\"opacity\", \".5\");\n    //   })\n    //   .attr(\"class\", \"totalRect\")\n    //   .attr(\"fill\", \"none\")\n    //   .attr(\"x\", 0)\n    //   .attr(\"pointer-events\", \"all\")\n    //   .attr(\"width\", width)\n    //   .attr(\"transform\", \"translate(0,0)\")\n    //   .attr(\"height\", height)\n    //   .transition()\n    //   .duration(500);\n    // // //////////////////////// Set the data on load ////////////////////////\n    // d3.set().add(chartData[chartData.length - 1]);\n    // let d = chartData[chartData.length - 1];\n    // lineTrace.attr(\"transform\", \"translate(\" + x(chartData.indexOf(d)) + \",0)\");\n    // myArrayOfKeys.forEach((item, index) => {\n    //   d3.select(`#${myID} .marker${index}`).attr(\n    //     \"transform\",\n    //     \"translate(\" +\n    //       x(chartData.indexOf(d)) +\n    //       \",\" +\n    //       y(d[myArrayOfKeys[index][\"dataKey\"]]) +\n    //       \")\"\n    //   );\n    // });\n    // myArrayOfKeys.forEach((item, index) => {\n    //   let myText =\n    //     d[myArrayOfKeys[index][\"dataKey\"]] !== null\n    //       ? numberFormatFn(d[myArrayOfKeys[index][\"dataKey\"]])\n    //       : \"\";\n    //   d3.select(`#${myID}Tooltip .lineTextConst${index}`).text(myText);\n    // });\n    // dateText.text(d.niceDate + \" \" + d.niceTime);\n    // d3.select(`#${myID} .mouse-line`).attr(\"y2\", height);\n  }\n\n  useEffect(() => {\n    createChart(chartData, valueArray, props.myID, props.numberFormatFn);\n  }, []);\n  return React.createElement(\"div\", {\n    ref: chart,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 318\n    },\n    __self: this\n  });\n}","map":{"version":3,"sources":["/Users/amandainnis/ReactProjects/react-site/portfolio/src/components/reusable/LineChart.js"],"names":["React","createRef","useState","useRef","useEffect","d3","moment","LineChart","props","chart","defaultHeight","containerElement","YOYdiff","data","chartData","setChartData","valueArray","setValueArray","prepMaxVal","myData","myArrayOfKeys","tempArr","tempStartVal","i","length","j","push","getMaxVal","tempArrB","tempMax","reduce","a","b","Math","max","tempMin","min","createChart","myID","numberFormatFn","current","innerHTML","tempMinMax","minVal","maxVal","margin","top","right","bottom","left","width","Number","isNaN","parseInt","select","style","height","justBisect","bisector","d","indexOf","x","scaleLinear","range","y","xAxis","axisBottom","tickFormat","niceDateAbbrev","tickPadding","yAxis","axisRight","ticks","createLineConsts","myArr","map","val","index","console","log","line","defined","lineConst"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,EAAqCC,MAArC,EAA6CC,SAA7C,QAA8D,OAA9D;AACA,OAAO,KAAKC,EAAZ,MAAoB,IAApB;AAEA,OAAO,KAAKC,MAAZ,MAAwB,QAAxB,C,CAEA;AACA;AACA;;AACA,eAAe,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACvC,QAAMC,KAAK,GAAGR,SAAS,EAAvB;AAEA,QAAMS,aAAa,GAAG,GAAtB;AACA,MAAIC,gBAAJ;AACA,MAAIC,OAAJ;;AALuC,oBAMLV,QAAQ,CAACM,KAAK,CAACK,IAAP,CANH;AAAA;AAAA,QAMhCC,SANgC;AAAA,QAMrBC,YANqB;;AAAA,qBAOHb,QAAQ,CAACM,KAAK,CAACQ,UAAP,CAPL;AAAA;AAAA,QAOhCA,UAPgC;AAAA,QAOpBC,aAPoB;;AASvC,WAASC,UAAT,CAAoBC,MAApB,EAA4BC,aAA5B,EAA2C;AACzC,QAAIC,OAAO,GAAG,EAAd;AACA,QAAIC,YAAY,GAAG,EAAnB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACK,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC;AACA,WAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,aAAa,CAACI,MAAlC,EAA0CC,CAAC,EAA3C,EAA+C;AAC7C,YAAIN,MAAM,CAACI,CAAD,CAAN,CAAUH,aAAa,CAACK,CAAD,CAAb,CAAiB,SAAjB,CAAV,MAA2C,IAA/C,EAAqD;AACnDJ,UAAAA,OAAO,CAACK,IAAR,CAAaP,MAAM,CAACI,CAAD,CAAN,CAAUH,aAAa,CAACK,CAAD,CAAb,CAAiB,SAAjB,CAAV,CAAb;AACD;AACF;AACF;;AACD,WAAOJ,OAAP;AACD;;AAED,WAASM,SAAT,CAAmBR,MAAnB,EAA2BC,aAA3B,EAA0C;AACxC;AACA,QAAIC,OAAO,GAAGH,UAAU,CAACC,MAAD,EAASC,aAAT,CAAxB;AACA,QAAIQ,QAAQ,GAAGV,UAAU,CAACC,MAAD,EAASC,aAAT,CAAzB;AAEA,QAAIS,OAAO,GAAGR,OAAO,CAACS,MAAR,CAAe,CAACC,CAAD,EAAIC,CAAJ,KAAUC,IAAI,CAACC,GAAL,CAASH,CAAT,EAAYC,CAAZ,CAAzB,CAAd;AACA,QAAIG,OAAO,GAAGP,QAAQ,CAACE,MAAT,CAAgB,CAACC,CAAD,EAAIC,CAAJ,KAAUC,IAAI,CAACG,GAAL,CAASL,CAAT,EAAYC,CAAZ,CAA1B,CAAd;AACA,WAAO;AAAEI,MAAAA,GAAG,EAAED,OAAP;AAAgBD,MAAAA,GAAG,EAAEL;AAArB,KAAP;AACD;;AACD,WAASQ,WAAT,CAAqBvB,SAArB,EAAgCM,aAAhC,EAA+CkB,IAA/C,EAAqDC,cAArD,EAAqE;AACnE5B,IAAAA,gBAAgB,GAAGF,KAAK,CAAC+B,OAAzB;AACA7B,IAAAA,gBAAgB,CAAC8B,SAAjB,GAA6B,EAA7B;AACA,QAAIC,UAAU,GAAGf,SAAS,CAACb,SAAD,EAAYM,aAAZ,CAA1B;AACA,QAAIuB,MAAM,GAAGD,UAAU,CAACN,GAAxB;AACA,QAAIQ,MAAM,GAAGF,UAAU,CAACR,GAAxB,CALmE,CAMnE;;AACA,QAAIW,MAAM,GAAG;AAAEC,MAAAA,GAAG,EAAE,EAAP;AAAWC,MAAAA,KAAK,EAAE,EAAlB;AAAsBC,MAAAA,MAAM,EAAE,CAA9B;AAAiCC,MAAAA,IAAI,EAAE;AAAvC,KAAb,CAPmE,CAQnE;;AACA,QAAIC,KAAK,GAAGC,MAAM,CAACC,KAAP,CACVC,QAAQ,CAAChD,EAAE,CAACiD,MAAH,CAAU3C,gBAAV,EAA4B4C,KAA5B,CAAkC,OAAlC,CAAD,CADE,IAGR,CAHQ,GAIRF,QAAQ,CAAChD,EAAE,CAACiD,MAAH,CAAU3C,gBAAV,EAA4B4C,KAA5B,CAAkC,OAAlC,CAAD,CAAR,GACAV,MAAM,CAACI,IADP,GAEAJ,MAAM,CAACE,KANX;AAOA,QAAIS,MAAM,GAAG,MAAMX,MAAM,CAACC,GAA1B;AACA,QAAIW,UAAU,GAAGpD,EAAE,CAACqD,QAAH,CAAYC,CAAC,IAAI7C,SAAS,CAAC8C,OAAV,CAAkBD,CAAlB,CAAjB,EAAuCV,IAAxD,CAjBmE,CAmBnE;;AAEA,QAAIY,CAAC,GAAGxD,EAAE,CAACyD,WAAH,GAAiBC,KAAjB,CAAuB,CAAC,CAAD,EAAIb,KAAJ,CAAvB,CAAR;AACA,QAAIc,CAAC,GAAG3D,EAAE,CAACyD,WAAH,GAAiBC,KAAjB,CAAuB,CAACP,MAAD,EAAS,CAAT,CAAvB,CAAR,CAtBmE,CAwBnE;;AAEA,QAAIS,KAAK,GAAG5D,EAAE,CACX6D,UADS,CACEL,CADF,EAEV;AAFU,KAGTM,UAHS,CAGE,UAASR,CAAT,EAAY;AACtB,aAAO7C,SAAS,CAAC6C,CAAD,CAAT,CAAaS,cAApB;AACD,KALS,EAMTC,WANS,CAMG,CANH,CAAZ;AAQA,QAAIC,KAAK,GAAGjE,EAAE,CACXkE,SADS,CACCP,CADD,EAETG,UAFS,CAEER,CAAC,IAAI;AACf,aAAOpB,cAAc,CAACoB,CAAD,CAArB;AACD,KAJS,EAKTa,KALS,CAKH,CALG,EAMTH,WANS,CAMG,CANH,CAAZ,CAlCmE,CA0CnE;AAEA;AACA;;AACA,aAASI,gBAAT,GAA4B;AAC1B,UAAIC,KAAK,GAAG,EAAZ;AACAtD,MAAAA,aAAa,CAACuD,GAAd,CAAkB,CAACC,GAAD,EAAMC,KAAN,KAAgB;AAChCC,QAAAA,OAAO,CAACC,GAAR,CAAYH,GAAZ;AACAF,QAAAA,KAAK,CAAChD,IAAN,CACErB,EAAE,CACC2E,IADH,GAEGC,OAFH,CAEWtB,CAAC,IAAI;AACZmB,UAAAA,OAAO,CAACC,GAAR,CAAYpB,CAAC,CAACiB,GAAD,CAAb;AACA,iBAAO,CAACzB,MAAM,CAACC,KAAP,CAAaO,CAAC,CAACiB,GAAD,CAAD,CAAO,SAAP,CAAb,CAAR;AACD,SALH,EAMGf,CANH,CAMK,CAACF,CAAD,EAAIpC,CAAJ,KAAU;AACX,iBAAOsC,CAAC,CAACtC,CAAD,CAAR;AACD,SARH,EASGyC,CATH,CASKL,CAAC,IAAIK,CAAC,CAACL,CAAC,CAACiB,GAAD,CAAD,CAAO,SAAP,CAAD,CATX,CADF;AAYD,OAdD;AAeA,aAAOF,KAAP;AACD;;AAED,UAAMQ,SAAS,GAAGT,gBAAgB,EAAlC;AACAK,IAAAA,OAAO,CAACC,GAAR,CAAYG,SAAZ,EAnEmE,CAoEnE;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACD;;AAED9E,EAAAA,SAAS,CAAC,MAAM;AACdiC,IAAAA,WAAW,CAACvB,SAAD,EAAYE,UAAZ,EAAwBR,KAAK,CAAC8B,IAA9B,EAAoC9B,KAAK,CAAC+B,cAA1C,CAAX;AACD,GAFQ,EAEN,EAFM,CAAT;AAIA,SAAO;AAAK,IAAA,GAAG,EAAE9B,KAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAP;AACD","sourcesContent":["import React, { createRef, useState, useRef, useEffect } from \"react\";\nimport * as d3 from \"d3\";\n\nimport * as moment from \"moment\";\n\n// each charted value has a display name for tooltip\n// tooltip may or may not have a charted value\n// each line takes a color\nexport default function LineChart(props) {\n  const chart = createRef();\n\n  const defaultHeight = 220;\n  var containerElement;\n  let YOYdiff;\n  const [chartData, setChartData] = useState(props.data);\n  const [valueArray, setValueArray] = useState(props.valueArray);\n\n  function prepMaxVal(myData, myArrayOfKeys) {\n    let tempArr = [];\n    let tempStartVal = [];\n    for (let i = 0; i < myData.length; i++) {\n      // push whatever arr[j] is in the array as a key into\n      for (let j = 0; j < myArrayOfKeys.length; j++) {\n        if (myData[i][myArrayOfKeys[j][\"dataKey\"]] !== null) {\n          tempArr.push(myData[i][myArrayOfKeys[j][\"dataKey\"]]);\n        }\n      }\n    }\n    return tempArr;\n  }\n\n  function getMaxVal(myData, myArrayOfKeys) {\n    // console.log(startVals, startValsRef);\n    let tempArr = prepMaxVal(myData, myArrayOfKeys);\n    let tempArrB = prepMaxVal(myData, myArrayOfKeys);\n\n    let tempMax = tempArr.reduce((a, b) => Math.max(a, b));\n    let tempMin = tempArrB.reduce((a, b) => Math.min(a, b));\n    return { min: tempMin, max: tempMax };\n  }\n  function createChart(chartData, myArrayOfKeys, myID, numberFormatFn) {\n    containerElement = chart.current;\n    containerElement.innerHTML = \"\";\n    let tempMinMax = getMaxVal(chartData, myArrayOfKeys);\n    let minVal = tempMinMax.min;\n    let maxVal = tempMinMax.max;\n    // let currentMonth = getCurrentMonth();\n    let margin = { top: 20, right: 60, bottom: 0, left: 10 };\n    //////////////////////// Establish the reused vals and the bound functions  ////////////////////////\n    let width = Number.isNaN(\n      parseInt(d3.select(containerElement).style(\"width\"))\n    )\n      ? 0\n      : parseInt(d3.select(containerElement).style(\"width\")) -\n        margin.left -\n        margin.right;\n    let height = 220 - margin.top;\n    let justBisect = d3.bisector(d => chartData.indexOf(d)).left;\n\n    //////////////////////// Set the scales  ////////////////////////\n\n    let x = d3.scaleLinear().range([0, width]);\n    let y = d3.scaleLinear().range([height, 0]);\n\n    //////////////////////// Set the axis ////////////////////////\n\n    let xAxis = d3\n      .axisBottom(x)\n      // .ticks(12)\n      .tickFormat(function(d) {\n        return chartData[d].niceDateAbbrev;\n      })\n      .tickPadding(6);\n\n    let yAxis = d3\n      .axisRight(y)\n      .tickFormat(d => {\n        return numberFormatFn(d);\n      })\n      .ticks(6)\n      .tickPadding(6);\n\n    //////////////////////// Define the lines and/or areas  ////////////////////////\n\n    // put consts of the lines into the global scope\n    // defined means it can show gaps, isNan means it can have zero as a value\n    function createLineConsts() {\n      let myArr = [];\n      myArrayOfKeys.map((val, index) => {\n        console.log(val);\n        myArr.push(\n          d3\n            .line()\n            .defined(d => {\n              console.log(d[val]);\n              return !Number.isNaN(d[val][\"dataKey\"]);\n            })\n            .x((d, i) => {\n              return x(i);\n            })\n            .y(d => y(d[val][\"dataKey\"]))\n        );\n      });\n      return myArr;\n    }\n\n    const lineConst = createLineConsts();\n    console.log(lineConst);\n    // //////////////////////// Define parent SVG  ////////////////////////\n\n    // const CVsvg = d3\n    //   .select(containerElement)\n    //   .append(\"svg\")\n    //   .attr(\"id\", myID)\n    //   .attr(\"width\", \"100%\")\n    //   .attr(\"height\", height + margin.top + margin.bottom + 40)\n    //   .append(\"g\")\n    //   .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    // // // //////////////////////// Loop through / sort data  ////////////////////////\n\n    // chartData.forEach(d => {\n    //   d = +d;\n    // });\n\n    // // // //////////////////////// Set the domains  ////////////////////////\n\n    // x.domain([\n    //   parseInt(d3.min(chartData, (d, i) => i)),\n    //   parseInt(d3.max(chartData, (d, i) => i))\n    // ]);\n    // y.domain([minVal, maxVal]);\n    // // y.domain([0, maxVal]);\n\n    // // // //////////////////////// Append the lines / areas  ////////////////////////\n\n    // myArrayOfKeys.forEach((item, index) => {\n    //   CVsvg.append(\"path\")\n    //     .datum(chartData)\n    //     .attr(\"class\", `line${index} line`)\n    //     .attr(\"d\", lineConst[index])\n    //     .transition()\n    //     .duration(500);\n    //   console.log(lineConst[index]);\n    // });\n\n    // // // ///////////////////////  Add the X & Y Axis  ////////////////////////\n\n    // CVsvg.append(\"g\")\n    //   .attr(\"class\", \"yAxis\")\n    //   .attr(\"transform\", \"translate(\" + (width + 6) + \",0)\")\n    //   .call(yAxis);\n\n    // CVsvg.append(\"g\")\n    //   .attr(\"class\", \"xAxis\")\n    //   .attr(\"transform\", \"translate(0,\" + height + \")\")\n    //   .call(xAxis);\n\n    // // // //////////////////////// Add Line Tracing on mouse and markers   ////////////////////////\n\n    // const lineTrace = CVsvg.append(\"line\")\n    //   .attr(\"class\", \"mouse-line x\")\n    //   .style(\"opacity\", 0.5)\n    //   .attr(\"y1\", 0)\n    //   .attr(\"y2\", height);\n\n    // function createMarkers() {\n    //   myArrayOfKeys.forEach((val, index) => {\n    //     CVsvg.append(\"g\")\n    //       .attr(\"class\", `marker${index}`)\n    //       .append(\"circle\")\n    //       .attr(\"class\", `line-marker line${index}`)\n    //       .transition()\n    //       .duration(500)\n    //       .attr(\"r\", 5);\n    //   });\n    // }\n\n    // createMarkers();\n    // // // //////////////////////// Tooltip  ////////////////////////\n\n    // const tooltipDiv = d3\n    //   .select(containerElement)\n    //   .append(\"div\")\n    //   .attr(\"class\", \"tooltipDiv\")\n    //   .attr(\"id\", `${myID}Tooltip`);\n    // const dateContainer = tooltipDiv\n    //   .append(\"div\")\n    //   .attr(\"class\", \"text-container\");\n    // dateContainer\n    //   .append(\"div\")\n    //   .attr(\"class\", \"label-style mr-1\")\n    //   .text(\"Date\");\n    // const dateText = dateContainer.append(\"div\").attr(\"class\", \"value-text\");\n\n    // function createLineDivTextConsts() {\n    //   let myArr = [];\n    //   myArrayOfKeys.map((val, index) => {\n    //     myArr.push(tooltipDiv.append(\"div\").attr(\"class\", \"text-container\"));\n    //   });\n    //   return myArr;\n    // }\n    // const lineTextContainer = createLineDivTextConsts();\n\n    // myArrayOfKeys.forEach((val, index) => {\n    //   lineTextContainer[index]\n    //     .append(\"div\")\n    //     .attr(\"class\", \"label-style mr-1\")\n    //     .text(val[\"dataKey\"]);\n\n    //   lineTextContainer[index].append(\"div\").attr(\"class\", `dot line${index}`);\n    // });\n\n    // function createLineTextConsts() {\n    //   let myArr = [];\n    //   myArrayOfKeys.map((item, index) => {\n    //     myArr.push(\n    //       lineTextContainer[index]\n    //         .append(\"div\")\n    //         .attr(\"class\", `value-text lineTextConst${index}`)\n    //     );\n    //   });\n    //   return myArr;\n    // }\n    // const lineTextConsts = createLineTextConsts();\n\n    // // //////////////////////// Add Rect to Capture Mouse Movements  ////////////////////////\n\n    // CVsvg.append(\"rect\")\n    //   .on(\"mouseover\", () => {\n    //     lineTrace.style(\"display\", null);\n    //     d3.select(`#${myID} .mouse-line`).style(\"opacity\", \"1\");\n    //   })\n    //   .on(\"mousemove\", () => {\n    //     let xy = d3.mouse(d3.event.currentTarget);\n\n    //     let x0 = x.invert(xy[0]);\n    //     let mouseIndex = justBisect(chartData, x0, 1);\n    //     let d0 = chartData[mouseIndex - 1];\n    //     let d1 = chartData[mouseIndex];\n    //     let d;\n    //     if (d1 !== undefined) {\n    //       d = x0 - chartData.indexOf(d0) > chartData.indexOf(d1) - x0 ? d1 : d0;\n    //     } else {\n    //       d = d0;\n    //     }\n\n    //     lineTrace.attr(\n    //       \"transform\",\n    //       \"translate(\" + x(chartData.indexOf(d)) + \",0)\"\n    //     );\n    //     myArrayOfKeys.forEach((item, index) => {\n    //       d3.select(`#${myID} .marker${index}`).attr(\n    //         \"transform\",\n    //         \"translate(\" +\n    //           x(chartData.indexOf(d)) +\n    //           \",\" +\n    //           y(d[myArrayOfKeys[index][\"dataKey\"]]) +\n    //           \")\"\n    //       );\n    //     });\n    //     myArrayOfKeys.forEach((item, index) => {\n    //       let myText =\n    //         d[myArrayOfKeys[index][\"dataKey\"]] !== null\n    //           ? numberFormatFn(d[myArrayOfKeys[index][\"dataKey\"]])\n    //           : \"\";\n    //       d3.select(`#${myID}Tooltip .lineTextConst${index}`).text(myText);\n    //     });\n\n    //     dateText.text(d.niceDate + \" \" + d.niceTime);\n\n    //     d3.select(`#${myID} .mouse-line`).attr(\"y2\", height);\n    //   })\n    //   .on(\"mouseleave\", () => {\n    //     d3.select(`#${myID} .mouse-line`).style(\"opacity\", \".5\");\n    //   })\n    //   .attr(\"class\", \"totalRect\")\n    //   .attr(\"fill\", \"none\")\n    //   .attr(\"x\", 0)\n    //   .attr(\"pointer-events\", \"all\")\n    //   .attr(\"width\", width)\n    //   .attr(\"transform\", \"translate(0,0)\")\n    //   .attr(\"height\", height)\n    //   .transition()\n    //   .duration(500);\n\n    // // //////////////////////// Set the data on load ////////////////////////\n\n    // d3.set().add(chartData[chartData.length - 1]);\n    // let d = chartData[chartData.length - 1];\n    // lineTrace.attr(\"transform\", \"translate(\" + x(chartData.indexOf(d)) + \",0)\");\n    // myArrayOfKeys.forEach((item, index) => {\n    //   d3.select(`#${myID} .marker${index}`).attr(\n    //     \"transform\",\n    //     \"translate(\" +\n    //       x(chartData.indexOf(d)) +\n    //       \",\" +\n    //       y(d[myArrayOfKeys[index][\"dataKey\"]]) +\n    //       \")\"\n    //   );\n    // });\n    // myArrayOfKeys.forEach((item, index) => {\n    //   let myText =\n    //     d[myArrayOfKeys[index][\"dataKey\"]] !== null\n    //       ? numberFormatFn(d[myArrayOfKeys[index][\"dataKey\"]])\n    //       : \"\";\n    //   d3.select(`#${myID}Tooltip .lineTextConst${index}`).text(myText);\n    // });\n    // dateText.text(d.niceDate + \" \" + d.niceTime);\n\n    // d3.select(`#${myID} .mouse-line`).attr(\"y2\", height);\n  }\n\n  useEffect(() => {\n    createChart(chartData, valueArray, props.myID, props.numberFormatFn);\n  }, []);\n\n  return <div ref={chart}></div>;\n}\n"]},"metadata":{},"sourceType":"module"}